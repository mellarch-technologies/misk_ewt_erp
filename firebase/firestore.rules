rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function hasRole(roleId) {
      return getUserData().roleId == roleId;
    }

    function isSuperAdmin() {
      return getUserData().isSuperAdmin == true;
    }

    // Users collection
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() &&
                      (isSuperAdmin() || hasRole('admin'));
      allow update: if isSignedIn() &&
                      (isSuperAdmin() ||
                       hasRole('admin') ||
                       request.auth.uid == userId);
      allow delete: if isSignedIn() && isSuperAdmin();
    }

    // Roles collection
    match /roles/{roleId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && isSuperAdmin();
    }

    // Initiatives collection
    match /initiatives/{initiativeId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() &&
                     (isSuperAdmin() ||
                      hasRole('admin') ||
                      hasRole('manager'));
    }

    // Campaigns collection
    match /campaigns/{campaignId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() &&
                     (isSuperAdmin() ||
                      hasRole('admin') ||
                      hasRole('manager'));
    }

    // Tasks collection
    match /tasks/{taskId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() &&
                      (isSuperAdmin() ||
                       hasRole('admin') ||
                       hasRole('manager') ||
                       resource.data.assignedTo == request.auth.uid);
      allow delete: if isSignedIn() &&
                      (isSuperAdmin() || hasRole('admin'));
    }

    // Events & Announcements collection
    match /events/{eventId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() &&
                     (isSuperAdmin() ||
                      hasRole('admin') ||
                      hasRole('manager'));
    }

    // Donations collection
    match /donations/{donationId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() &&
                     (isSuperAdmin() ||
                      hasRole('admin') ||
                      hasRole('manager'));
    }

    // Public pending donations: allow unauthenticated create with strict validation; restrict read/update to admins
    match /public_pending_donations/{pendingId} {
      // Create allowed for anyone if payload is safe and minimal
      allow create: if
        // Amount and currency
        (request.resource.data.amount is number && request.resource.data.amount > 0) &&
        (request.resource.data.currency == 'INR') &&
        // Status/method/source
        (request.resource.data.status == 'pending') &&
        ((request.resource.data.method == 'bank') ||
         (request.resource.data.method == 'upi') ||
         (request.resource.data.method == 'razorpay')) &&
        (request.resource.data.source == 'public_app') &&
        // Donor block (minimal required)
        (request.resource.data.donor is map) &&
        (request.resource.data.donor.name is string) &&
        (request.resource.data.donor.email is string) &&
        // Server timestamps must be provided (type check only)
        (request.resource.data.createdAt is timestamp) &&
        (request.resource.data.updatedAt is timestamp) &&
        // Disallow privileged fields
        !(request.resource.data.keys().hasAny(['receiptNo','bankReconciled','reconciledAt','receivedAt','txnId','initiative','campaign']));

      // Admins can read/update/delete for reconciliation workflows
      allow read, update, delete: if isSignedIn() && (isSuperAdmin() || hasRole('admin') || hasRole('manager'));
    }

    // Rate limiting function (placeholder)
    function isNotRateLimited() {
      return request.time > resource.data.lastAccess + duration.value(1, 'm');
    }

    // Request logging (optional, for monitoring)
    match /logs/{logId} {
      allow create: if isSignedIn();
    }
  }
}
